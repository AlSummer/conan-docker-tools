// These are things to parameterize/read/write from/to .env file
List gccVersions = ['5', '6', '7', '8', '9', '10', '11']
List clangVersions = ['10', '11', '12']
boolean isMaster = (scm.branches[0].name == 'master')
echo ">> scm.branches[0].name: ${scm.branches[0].name}"
List<String> environment = []

def configure_docker() {
    withCredentials([usernamePassword(credentialsId: 'c3istg-dad-docker', usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD')]) {
        sh 'docker login --username $USERNAME --password $PASSWORD c3istg-dad-docker.jfrog.io'
    }
}

def docker_compose_build(String image, String expectedImage, List<String> envvars) {
    configure_docker()

    withEnv(envvars) {
        sh "docker-compose build $image"
        // String output = sh(script: "docker-compose build $image", returnStdout: true).trim()
        // assert output.contains(expectedImage): "Expected image name '$expectedImage' not found in output:\n\n$output\n\n"
        echo ">> Generated $expectedImage"
    }

    sh 'docker push $expectedImage'
}



node('Linux') {
    stage('Checkout the sources') {
        checkout scm
    }

    String conanVersion = null
    String dockerUsername = 'c3istg-dad-docker.jfrog.io'
    String dockerTag = sh(script: 'git rev-parse HEAD', returnStdout: true).trim()
    stage('Configure the job') {
        String content = readFile('modern/.env')

        // Get Conan version from file
        def matcher = content =~ /CONAN_VERSION=([\d.]+)/
        conanVersion = matcher[0][1]
        echo "Found Conan version: ${conanVersion}"

        // Get Docker username from file
        //matcher = content =~ /DOCKER_USERNAME=([\w.]+)/
        //dockerUsername = matcher[0][1]
        echo "Found Docker username: ${dockerUsername}"

        // Get the docker tag
        //String output = sh(script: 'git rev-parse HEAD', returnStdout: true).trim()
        //dockerTag = output //isMaster ? conanVersion : commit
        if (isMaster) {
            dockerTag = conanVersion
        }
        echo ">>> Docker tag: $dockerTag"
        environment.add("DOCKER_TAG=${dockerTag}")
    }

    stage('Detect changes') {
    // TODO: Dependending on the files affected by the PR we might want to run
    //   some building or other
    }

    stage('Configure the job') {
        sh 'pip install docker-compose'
    }

    stage('Xenial - Build base image') {
        String expectedImage = "${dockerUsername}/base-ubuntu16.04:${dockerTag}"
        dir('modern') {
            docker_compose_build('base', expectedImage, environment)
            echo "pytest tests --image ${expectedImage} --service base"
        }
    }

    // Build GCC in parallel
    Map gccBuilds = [:]
    gccVersions.each { v ->
        String gccVersion = v
        gccBuilds["GCC ${gccVersion}"] = {
            //node('Linux') {
                //stage('Checkout the sources') {
                //    checkout scm
                //}

            stage("GCC ${gccVersion} deploy") {
                    dir('modern') {
                        String expectedImage = "${dockerUsername}/gcc${gccVersion}-ubuntu16.04:${dockerTag}"
                        docker_compose_build("gcc${gccVersion}", expectedImage, environment)
                        echo "pytest tests --image ${expectedImage} --service deploy"
                    }
            }
            stage("GCC ${gccVersion} jenkins") {
                    dir('modern') {
                        String expectedImage = "${dockerUsername}/gcc${gccVersion}-ubuntu16.04-jenkins:${dockerTag}"
                        docker_compose_build("gcc${gccVersion}-jenkins", expectedImage, environment)
                        echo "pytest tests --image ${expectedImage} --service jenkins"
                    }
            }
        //}
        }
    }
    gccBuilds.failFast = true
    parallel(gccBuilds)

    stage('Run GCC xtests') {
        echo 'Run tests that check binaries work in compatible images'
    }

    // Build Clang in parallel
    Map clangBuilds = [:]
    clangVersions.each { v ->
        String clangVersion = v
        clangBuilds["Clang ${clangVersion}"] = {
            //node('Linux') {
                //stage('Checkout the sources') {
                //    checkout scm
                //}

            stage("Clang ${clangVersion} deploy") {
                    dir('modern') {
                        String expectedImage = "${dockerUsername}/clang${clangVersion}-ubuntu16.04:${dockerTag}"
                        docker_compose_build("clang${gccVersion}", expectedImage, environment)
                        echo "pytest tests --image ${expectedImage} --service deploy"
                    }
            }
            stage("Clang ${clangVersion} jenkins") {
                    dir('modern') {
                        String expectedImage = "${dockerUsername}/clang${clangVersion}-ubuntu16.04-jenkins:${dockerTag}"
                        docker_compose_build("clang${clangVersion}-jenkins", expectedImage, environment)
                        echo "pytest tests --image ${expectedImage} --service jenkins"
                    }
            }
        //}
        }
    }
    clangBuilds.failFast = true
    parallel(clangBuilds)

    stage('Run Clang xtests') {
        echo 'Run tests that check binaries work in compatible images'
    }

    // TODO: If master branch
    stage('Upload images') {
        echo 'Upload images'
    }
}
