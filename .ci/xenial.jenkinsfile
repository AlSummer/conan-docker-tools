// These are things to parameterize/read/write from/to .env file
List gccVersions = ['5', '6', '7', '8', '9', '10', '11']
List clangVersions = ['10', '11', '12']

def docker_compose_build(String image, String expectedImage) {
    // Just to be sure we use the expected Conan version
    String output = sh(script: "docker-compose build $image", returnStdout: true).trim()
    assert output.contains(expectedImage): "Expected image name '$expectedImage' not found in output:\n\n$output\n\n"
    echo ">> Generated $expectedImage"
}

node('Linux') {
    stage('Checkout the sources') {
        checkout scm
    }

    String conanVersion = null
    String dockerUsername = null
    stage('Input arguments') {
        String content = readFile('modern/.env')

        // Get Conan version from file
        def matcher = content =~ /CONAN_VERSION=([\d.]+)/
        conanVersion = matcher[0][1]
        echo "Found Conan version: ${conanVersion}"

        // Get Docker username from file
        matcher = content =~ /DOCKER_USERNAME=([\w.]+)/
        dockerUsername = matcher[0][1]
        echo "Found Docker username: ${dockerUsername}"
    }

    stage('Detect changes') {
    // TODO: Dependending on the files affected by the PR we might want to run
    //   some building or other
    }

    stage('Install requirements') {
        sh 'pip install docker-compose'
    }

    stage('Xenial - Build base image') {
        String expectedImage = "${dockerUsername}/base-ubuntu16.04:${conanVersion}"
        dir('modern') {
            docker_compose_build('base', expectedImage)
            echo "pytest tests --image ${expectedImage} --service base"
        }
    }

    // Build GCC in parallel
    Map gccBuilds = [:]
    gccVersions.each { v ->
        String gccVersion = v
        gccBuilds["GCC ${gccVersion}"] = {
            stage("GCC ${gccVersion} deploy") {
                String expectedImage = "${dockerUsername}/gcc${gccVersion}-ubuntu16.04:${conanVersion}"
                docker_compose_build("gcc${gccVersion}", expectedImage)
                echo "pytest tests --image ${expectedImage} --service deploy"
            }
            stage("GCC ${gccVersion} jenkins") {
                String expectedImage = "${dockerUsername}/gcc${gccVersion}-ubuntu16.04-jenkins:${conanVersion}"
                docker_compose_build("gcc${gccVersion}-jenkins", expectedImage)
                echo "pytest tests --image ${expectedImage} --service jenkins"
            }
        }
    }
    gccBuilds.failFast = true
    parallel(gccBuilds)

    stage('Run GCC xtests') {
        echo 'Run tests that check binaries work in compatible images'
    }

    // Build Clang in parallel
    Map clangBuilds = [:]
    clangVersions.each { v ->
        String clangVersion = v
        clangBuilds["Clang ${clangVersion}"] = {
            stage("Clang ${clangVersion} deploy") {
                String expectedImage = "${dockerUsername}/clang${clangVersion}-ubuntu16.04:${conanVersion}"
                docker_compose_build("clang${gccVersion}", expectedImage)
                echo "pytest tests --image ${expectedImage} --service deploy"
            }
            stage("Clang ${clangVersion} jenkins") {
                String expectedImage = "${dockerUsername}/clang${clangVersion}-ubuntu16.04-jenkins:${conanVersion}"
                docker_compose_build("clang${clangVersion}-jenkins", expectedImage)
                echo "pytest tests --image ${expectedImage} --service jenkins"
            }
        }
    }
    clangBuilds.failFast = true
    parallel(clangBuilds)

    stage('Run Clang xtests') {
        echo 'Run tests that check binaries work in compatible images'
    }

    // TODO: If master branch
    stage('Upload images') {
        echo 'Upload images'
    }
}
