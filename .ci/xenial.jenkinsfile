
// Maybe parameterized somewhere
List gccVersions = ['5.5.0', '6.5.0', '7.5.0', '8.4.0', '9.3.0', '10.3.0', '11.1.0']
List clangVersions = ['10.0.1', '11.1.0', '12.0.0']
String distro = 'ubuntu16.04'
String dockerUsername = 'center-c3i-docker.jfrog.io'

String versionMajor(String version) {
    def matcher = (version =~ /(\d+).(\d+).(\d+)/)
    return matcher[0][1] as String
}

def buildImage(String latestMaster, String latestBranch, String expectedImage, String buildArgs, String target = null) {
    withCredentials([usernamePassword(credentialsId: 'center-c3i-docker', usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD')]) {
        sh 'docker login --username $USERNAME --password $PASSWORD ${dockerUsername}'
    }

    String cacheFrom = ''
    if (0 == sh(script: "docker pull ${latestMaster}", returnStatus: true)) {
        cacheFrom = "${cacheFrom} --cache-from ${latestMaster}"
    }
    if (0 == sh(script: "docker pull ${latestBranch}", returnStatus: true)) {
        cacheFrom = "${cacheFrom} --cache-from ${latestBranch}"
    }

    sh "docker build ${cacheFrom} -t ${expectedImage} ${buildArgs} ${target ? "--target $target": ''} ."

    sh "docker push ${expectedImage}"
    sh "docker tag ${expectedImage} ${latestBranch}"
    sh "docker push ${latestBranch}"
}

node('Linux') {
    stage('Checkout the sources') {
        checkout scm
    }

    String branchName = scm.branches[0].name
    boolean isMaster = (branchName == 'master')
    echo ">> scm.branches[0].name: ${branchName}"
    String commit = sh(script: 'git rev-parse HEAD', returnStdout: true).trim()

    Map originalEnvironment = [:]
    Map job_environment = [:]
    stage('Parse environment file') {
        String content = readFile('modern/.env')
        content.split('\n').each({ it.trim() }).findAll({ it.size() && !it.startsWith('#') }).each {
            def (name, value) = it.split('=')
            originalEnvironment.put(name, value)
            job_environment.put(name, value)
    }
        echo "originalEnvironment:\n\n${ originalEnvironment.collect({ k, v -> "${k }=${v }"}).join('\n')}"

        // Environment to use in this job:
        job_environment['DOCKER_USERNAME'] = dockerUsername
        job_environment['DOCKER_TAG'] = "${branchName}-${commit}"
        //job_environment['BUILDKIT_INLINE_CACHE'] = '1'  // This makes the image usable as cache source
        echo "job_environment:\n\n${ job_environment.collect({ k, v -> "${k }=${v }"}).join('\n')}"
}
    String buildArgs = job_environment.collect({ k, v -> "--build-arg ${k }=${v }"}).join(' ') as String

    stage('Detect changes') {
    // TODO: Dependending on the files affected by the PR we might want to run
    //   some building or other
    }

    //stage('Configure the job') {
        //sh 'pip install docker-compose'
    //}

    stage('Xenial - Build base image') {
        String expectedImage = "${dockerUsername}/base-ubuntu16.04:${branchName}-${commit}"
        String latestBranch = "${dockerUsername}/base-ubuntu16.04:${branchName}-latest"
        String latestMaster = "${dockerUsername}/base-ubuntu16.04:master-latest"
        dir('modern/base') {
            buildImage(latestMaster, latestBranch, expectedImage, buildArgs)
        }

        dir('modern') {
            echo "pytest tests --image ${expectedImage} --service base"
        }
    }

    // Build GCC in parallel
    Map gccBuilds = [:]
    gccVersions.each { v ->
        String gccVersion = v
        String gccVersionMajor = versionMajor(gccVersion)
        gccBuilds["GCC ${gccVersionMajor}"] = {
            String mainImage = "${dockerUsername}/gcc${gccVersionMajor}-ubuntu16.04:${branchName}-${commit}"
            String gccBuildArgs = "${buildArgs} --build-arg GCC_VERSION=${gccVersion}"

            node('Linux') {
                stage('Checkout the sources') {
                    checkout scm
                }

                stage("GCC ${gccVersion} builder") {
                    String expectedImage = "${dockerUsername}/gcc${gccVersionMajor}-ubuntu16.04-builder:${branchName}-${commit}"
                    String latestBranch = "${dockerUsername}/gcc${gccVersionMajor}-ubuntu16.04-builder:${branchName}-latest"
                    String latestMaster = "${dockerUsername}/gcc${gccVersionMajor}-ubuntu16.04-builder:master-latest"

                    dir('modern/gcc') {
                        buildImage(latestMaster, latestBranch, expectedImage, gccBuildArgs, 'builder')
                    }

                    dir('modern') {
                        echo "pytest tests --image ${expectedImage} --service builder"
                    }
                }

                stage("GCC ${gccVersion} deploy") {
                    String expectedImage = mainImage
                    String latestBranch = "${dockerUsername}/gcc${gccVersionMajor}-ubuntu16.04:${branchName}-latest"
                    String latestMaster = "${dockerUsername}/gcc${gccVersionMajor}-ubuntu16.04:master-latest"

                    dir('modern/gcc') {
                        buildImage(latestMaster, latestBranch, expectedImage, gccBuildArgs, 'deploy')
                    }

                    dir('modern') {
                        echo "pytest tests --image ${expectedImage} --service deploy"
                    }
                }

                stage("GCC ${gccVersion} jenkins") {
                    String expectedImage = "${dockerUsername}/gcc${gccVersionMajor}-ubuntu16.04-jenkins:${branchName}-${commit}"
                    String latestBranch = "${dockerUsername}/gcc${gccVersionMajor}-ubuntu16.04-jenkins:${branchName}-latest"
                    String latestMaster = "${dockerUsername}/gcc${gccVersionMajor}-ubuntu16.04-jenkins:master-latest"

                    dir('modern/jenkins') {
                        buildImage(latestMaster, latestBranch, expectedImage, "--build-arg SOURCE_CONANIO_IMAGE=${mainImage}")
                    }

                    dir('modern') {
                        echo "pytest tests --image ${expectedImage} --service jenkins"
                    }
                }
            }
        }
    }
    gccBuilds.failFast = true
    parallel(gccBuilds)

    /*
    String conanVersion = null
    String dockerUsername = 'center-c3i-docker.jfrog.io'
    String dockerTag = "${branchName}-${sh(script: 'git rev-parse HEAD', returnStdout: true).trim()}"
    stage('Configure the job') {
        String content = readFile('modern/.env')

        // Get Conan version from file
        def matcher = content =~ /CONAN_VERSION=([\d.]+)/
        conanVersion = matcher[0][1]
        echo "Found Conan version: ${conanVersion}"

        // Get Docker username from file
        //matcher = content =~ /DOCKER_USERNAME=([\w.]+)/
        //dockerUsername = matcher[0][1]
        echo "Found Docker username: ${dockerUsername}"
        environment.add("DOCKER_USERNAME=${dockerUsername}")

        // Get the docker tag
        //String output = sh(script: 'git rev-parse HEAD', returnStdout: true).trim()
        //dockerTag = output //isMaster ? conanVersion : commit
        echo ">>> Docker tag: $dockerTag"
        environment.add("DOCKER_TAG=${dockerTag}")
    }

    stage('Detect changes') {
    // TODO: Dependending on the files affected by the PR we might want to run
    //   some building or other
    }

    stage('Configure the job') {
    //sh 'pip install docker-compose'
    }

    stage('Xenial - Build base image') {
        String expectedImage = "${dockerUsername}/base-ubuntu16.04:${dockerTag}"
        String latestImage = "${dockerUsername}/base-ubuntu16.04:${branchName}-latest"
        dir('modern') {
            docker_compose_build('base', expectedImage, latestImage, environment)
            echo "pytest tests --image ${expectedImage} --service base"
        }
    }

    // Build GCC in parallel
    Map gccBuilds = [:]
    gccVersions.each { v ->
        String gccVersion = v
        gccBuilds["GCC ${gccVersion}"] = {
            node('Linux') {
                stage('Checkout the sources') {
                    checkout scm
                }

                stage("GCC ${gccVersion} deploy") {
                    dir('modern') {
                        String expectedImage = "${dockerUsername}/gcc${gccVersion}-ubuntu16.04:${dockerTag}"
                        String latestImage = "${dockerUsername}/gcc${gccVersion}-ubuntu16.04:${branchName}-latest"
                        docker_compose_build("gcc${gccVersion}", expectedImage, latestImage, environment)
                        echo "pytest tests --image ${expectedImage} --service deploy"
                    }
                }
                stage("GCC ${gccVersion} jenkins") {
                    dir('modern') {
                        String expectedImage = "${dockerUsername}/gcc${gccVersion}-ubuntu16.04-jenkins:${dockerTag}"
                        String latestImage = "${dockerUsername}/gcc${gccVersion}-ubuntu16.04-jenkins:${branchName}-latest"
                        docker_compose_build("gcc${gccVersion}-jenkins", expectedImage, latestImage, environment)
                        echo "pytest tests --image ${expectedImage} --service jenkins"
                    }
                }
            }
        }
    }
    gccBuilds.failFast = true
    parallel(gccBuilds)

    stage('Run GCC xtests') {
        echo 'Run tests that check binaries work in compatible images'
    }

    // Build Clang in parallel
    Map clangBuilds = [:]
    clangVersions.each { v ->
        String clangVersion = v
        clangBuilds["Clang ${clangVersion}"] = {
            node('Linux') {
                stage('Checkout the sources') {
                    checkout scm
                }

                stage("Clang ${clangVersion} deploy") {
                    dir('modern') {
                        String expectedImage = "${dockerUsername}/clang${clangVersion}-ubuntu16.04:${dockerTag}"
                        String latestImage = "${dockerUsername}/clang${clangVersion}-ubuntu16.04:${branchName}-latest"
                        docker_compose_build("clang${clangVersion}", expectedImage, latestImage, environment)
                        echo "pytest tests --image ${expectedImage} --service deploy"
                    }
                }
                stage("Clang ${clangVersion} jenkins") {
                    dir('modern') {
                        String expectedImage = "${dockerUsername}/clang${clangVersion}-ubuntu16.04-jenkins:${dockerTag}"
                        String latestImage = "${dockerUsername}/clang${clangVersion}-ubuntu16.04-jenkins:${branchName}-latest"
                        docker_compose_build("clang${clangVersion}-jenkins", expectedImage, latestImage, environment)
                        echo "pytest tests --image ${expectedImage} --service jenkins"
                    }
                }
            }
        }
    }
    clangBuilds.failFast = true
    parallel(clangBuilds)

    stage('Run Clang xtests') {
        echo 'Run tests that check binaries work in compatible images'
    }

    // TODO: If master branch
    stage('Upload images') {
        echo 'Upload images'
    }
    */
}
